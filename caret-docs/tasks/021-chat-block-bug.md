# Task #021: Agent 수행중 채팅 입력창의 보내기 버튼이 막혀서 진행이 안되는 상태

**프로젝트**: Caret  
**담당자**: luke  
**우선순위**: 📋 **High - 이용에 매우 불편함**  
**상태**: ⏸️ **진행 중단 - 추가 분석 필요**

## 🎯 **목표: 입력창 보내기 버튼의 막히는 원인 파악 후, 해당 대안 마련**
* 주요 현상 :
  - `execute_command` 또는 `browser_action`과 같은 상호작용형 도구가 실행될 때, 채팅 입력창이 비활성화되어 사용자가 추가적인 입력을 할 수 없는 문제.
  - 입력창이 활성화되더라도, 메시지를 보내면 화면에 표시되지 않고 사라지는 현상 발생.

## 🔍 **원인 분석 (2025-07-11)**
1.  **`api_req_started`에 의한 성급한 비활성화**: `useDeepCompareEffect` 훅에서 `api_req_started` 메시지를 받으면, 후속 메시지의 종류와 상관없이 즉시 입력창을 비활성화(`setSendingDisabled(true)`)하는 것이 1차 원인이었음.
2.  **`clineAsk` 상태의 불안정성**: 상호작용형 도구(`browser_action`, `command_output` 등)가 시작될 때 `clineAsk` 상태가 설정되지만, 이후 다른 `say` 메시지(예: `browser_action_result`)가 도착하면 `clineAsk`가 `undefined`로 초기화됨.
3.  **메시지 전송 로직의 한계**: `handleSendMessage` 함수는 `clineAsk` 상태가 유효할 때만 백엔드로 메시지를 전송하도록 되어 있음. `clineAsk`가 불안정하게 초기화되면서, 사용자가 보낸 메시지가 백엔드로 전송되지 못하고 누락되는 현상 발생.
4.  **UI 피드백 부재**: 사용자 메시지는 백엔드로부터 `user_feedback` 응답을 받아야 화면에 그려짐. 백엔드가 메시지를 처리하지 못하면, 사용자 입장에서는 메시지가 그냥 사라지는 것처럼 보임.

## 💡 **시도된 해결 방안 및 결과**
1.  **`say` 메시지 타입에 따른 입력창 활성화**: `browser_action`, `command_output` 등 특정 `say` 메시지를 받았을 때 `setSendingDisabled(false)`를 호출하여 입력창을 강제로 활성화.
    *   **결과**: 입력창은 활성화되었으나, `clineAsk` 상태가 여전히 불안정하여 메시지 전송 시 누락되는 문제 발생.
2.  **`handleSendMessage` 로직 수정**: `clineAsk`가 `browser_action` 또는 `command_output`일 때는 메시지 전송 후에도 상태를 초기화하지 않도록 수정.
    *   **결과**: `clineAsk`가 `undefined`인 상태에서 메시지를 보내는 근본적인 문제를 해결하지 못함.
3.  **`clineAsk` 상태 유지 로직 강화**: `browser_action_result`와 같은 후속 `say` 메시지가 와도 `clineAsk` 상태를 유지하도록 수정.
    *   **결과**: `clineAsk` 상태는 유지되었으나, 여전히 메시지 전송이 백엔드에서 처리되지 않는 것으로 보임.
4.  **낙관적 UI 업데이트 (Optimistic Update)**: 메시지를 보내는 즉시 `vscode.setState`를 사용해 화면에 미리 표시.
    *   **결과**: UI상으로는 메시지가 보이는 것처럼 수정했으나, 타입스크립트 오류가 발생하여 수정. 오류 수정 후에도 근본적인 백엔드 미처리 문제는 해결되지 않음.

## 📖 **다음 세션을 위한 가이드**
**문제점 재정의:**
현재 문제는 프론트엔드의 상태 관리(`clineAsk`, `sendingDisabled`)와 백엔드의 메시지 처리 로직이 복합적으로 얽혀있는 것으로 보입니다. 사용자가 상호작용형 도구 실행 중에 보낸 메시지가 백엔드에서 올바르게 처리되지 않고 누락되는 것이 핵심입니다. `CheckpointTracker` 관련 에러가 계속 발생하는 것도 백엔드 태스크 처리에 영향을 줄 수 있는 잠재적 요인입니다.

**다음 단계:**
다음 작업자는 아래 순서대로 작업을 재개해 주세요.

1.  **백엔드 로직 분석 (가장 중요)**:
    *   `Task` 클래스 (`src/core/task/index.ts`)의 `askResponse`와 메시지 처리 관련 로직을 집중적으로 분석해야 합니다.
    *   `browser_action`이나 `command_output`이 활성화된 상태에서 `messageResponse` 타입의 `askResponse`가 들어왔을 때, 백엔드가 이를 어떻게 처리하는지 디버깅이 필요합니다.
    *   특히, 현재 실행 중인 도구(`browser_action` 등)의 작업과 새로운 사용자 메시지 처리가 어떻게 조율되는지 확인해야 합니다.
2.  **상태 관리 단순화**:
    *   현재의 복잡한 `useEffect`와 `clineAsk` 상태 관리가 오히려 문제를 악화시키고 있을 수 있습니다.
    *   AI가 응답 중(`isStreaming` 또는 `partial` 메시지 수신)이거나, 명시적인 사용자 응답(`Approve`/`Reject` 버튼)을 기다리는 경우가 아니라면 **기본적으로 입력창을 활성화**하는 방향으로 로직을 대폭 단순화하는 것을 고려해볼 수 있습니다.
3.  **메시지 큐 도입 검토 (장기적 해결책)**:
    *   사용자가 보낸 메시지가 AI의 현재 작업 때문에 즉시 처리될 수 없다면, 이를 임시 큐에 저장했다가 AI가 준비되었을 때 순차적으로 처리하는 방식이 가장 이상적인 사용자 경험을 제공할 것입니다. 이것이 가능한지 백엔드 구조를 검토해볼 필요가 있습니다.
4.  **`CheckpointTracker` 에러 해결**:
    *   `No workspace detected` 에러가 계속 발생하고 있습니다. 테스트 환경에서 워크스페이스가 올바르게 인식되도록 하거나, 해당 에러가 발생해도 태스크 진행에 문제가 없도록 예외 처리를 강화해야 합니다.
