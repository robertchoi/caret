# Caret Test Code Writing Standards

## 1. Overview

This document defines the specific standards and rules to be followed when writing test code in the Caret project. All developers and AI assistants must adhere to these standards to write consistent and high-quality test code.

## 2. Core Principles

### 2.1 100% Test Coverage Principle
- **Caret-specific Code**: Must achieve 100% coverage.
- **All Functions**: Test all functions, regardless of whether they are public or private.
- **All Branches**: Test all branches, including if/else, switch, ternary operators, etc.
- **Exception Handling**: Test all error cases and exception scenarios.

### 2.2 TDD Development Process
1. **Red**: Write failing tests first.
2. **Green**: Write the minimum code to pass the tests.
3. **Refactor**: Improve code quality (tests continue to pass).

### 2.3 Test-First Principle
- **Before Development Starts**: Write test code first.
- **When Adding Features**: Add tests, then implement the feature.
- **When Fixing Bugs**: Write a test to reproduce the bug, then fix it.

## 3. File Structure and Naming Conventions

### 3.1 Test File Location

#### 3.1.1 Backend Tests (caret-src/)
```
caret-src/
├── core/
│   ├── webview/
│   │   ├── CaretProvider.ts
│   │   └── __tests__/
│   │       └── CaretProvider.test.ts
│   └── utils/
│       ├── caret-logger.ts
│       └── caret-logger.test.ts  # Same directory allowed
```

#### 3.1.2 Frontend Tests (webview-ui/src/caret/)
```
webview-ui/src/caret/
├── components/
│   ├── CaretWelcome.tsx
│   └── __tests__/
│       └── CaretWelcome.test.tsx
├── hooks/
│   ├── useCaretState.ts
│   └── useCaretState.test.ts
└── utils/
    ├── i18n.ts
    └── __tests__/
        └── i18n.test.ts
```

### 3.2 Test File Naming Conventions

#### 3.2.1 Basic Rules
- **Unit Tests**: `{FileName}.test.{ts|tsx}`
- **Integration Tests**: `{FeatureName}.integration.test.{ts|tsx}`
- **E2E Tests**: `{WorkflowName}.e2e.test.{ts|tsx}`

#### 3.2.2 Special Cases
- **Utility Functions**: `{utilityName}.test.ts`
- **Hook Tests**: `{hookName}.test.ts`
- **API Tests**: `{apiName}.api.test.ts`

## 4. Test Code Structure Standards

### 4.1 Basic Test Structure

#### 4.1.1 Standard Template
```typescript
// {FileName}.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'; // or jest
import { {TargetClass} } from '../{FileName}';

describe('{TargetClass}', () => {
  let instance: {TargetClass};

  beforeEach(() => {
    // Initialization before each test
    instance = new {TargetClass}();
  });

  afterEach(() => {
    // Cleanup after each test
    jest.clearAllMocks();
  });

  describe('constructor', () => {
    it('should initialize with default values', () => {
      // Constructor test
    });
  });

  describe('{methodName}', () => {
    it('should {expected behavior} when {condition}', () => {
      // Method-specific test
    });
  });
});
```

#### 4.1.2 React Component Test Template
```typescript
// {ComponentName}.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { {ComponentName} } from '../{ComponentName}';

describe('{ComponentName}', () => {
  const defaultProps = {
    // Define default props
  };

  it('should render correctly', () => {
    render(<{ComponentName} {...defaultProps} />);
    expect(screen.getByRole('...')).toBeInTheDocument();
  });

  it('should handle user interaction', async () => {
    const mockHandler = vi.fn();
    render(<{ComponentName} {...defaultProps} onAction={mockHandler} />);
    
    fireEvent.click(screen.getByRole('button'));
    
    await waitFor(() => {
      expect(mockHandler).toHaveBeenCalledTimes(1);
    });
  });
});
```

### 4.2 Test Grouping (describe blocks)

#### 4.2.1 Class Test Grouping
```typescript
describe('CaretLogger', () => {
  describe('constructor', () => {
    // Constructor-related tests
  });

  describe('info method', () => {
    // info method-related tests
  });

  describe('error method', () => {
    // error method-related tests
  });

  describe('private methods', () => {
    // Private method tests (if necessary)
  });
});
```

#### 4.2.2 Feature-specific Grouping
```typescript
describe('i18n utility', () => {
  describe('translation', () => {
    // Translation feature tests
  });

  describe('language detection', () => {
    // Language detection feature tests
  });

  describe('fallback handling', () => {
    // Fallback handling tests
  });
});
```

## 5. Test Case Writing Standards

### 5.1 Test Name Rules

#### 5.1.1 Naming Pattern
```typescript
// Pattern: should {expected result} when {condition}
it('should return user data when valid ID is provided', () => {});
it('should throw error when invalid ID is provided', () => {});
it('should render loading state when data is fetching', () => {});

// Pattern: should {action} {object}
it('should validate email format', () => {});
it('should save user preferences', () => {});
it('should clear cache on logout', () => {});
```

#### 5.1.2 Good Test Names vs. Bad Test Names
```typescript
// ✅ Good Example
it('should return error message when API key is missing', () => {});
it('should render Korean text correctly in welcome component', () => {});
it('should log info message with timestamp and context', () => {});

// ❌ Bad Example
it('should work', () => {});
it('test API', () => {});
it('check function', () => {});
```

### 5.2 AAA Pattern (Arrange-Act-Assert)

#### 5.2.1 Basic Structure
```typescript
it('should format log message with context', () => {
  // Arrange
  const logger = new CaretLogger('test-context');
  const message = 'test message';
  const level = 'INFO';

  // Act
  const result = logger.formatMessage(level, message);

  // Assert
  expect(result).toBe('[INFO][test-context] test message');
});
```

#### 5.2.2 Complex Cases
```typescript
it('should handle API error and show user-friendly message', async () => {
  // Arrange
  const mockApiClient = {
    fetchData: vi.fn().mockRejectedValue(new Error('Network error'))
  };
  const component = render(<DataComponent apiClient={mockApiClient} />);
  const showErrorSpy = vi.spyOn(window, 'alert');

  // Act
  fireEvent.click(screen.getByRole('button', { name: 'Load Data' }));
  await waitFor(() => {
    expect(screen.getByText('Loading...')).not.toBeInTheDocument();
  });

  // Assert
  expect(showErrorSpy).toHaveBeenCalledWith('Failed to load data.');
  expect(screen.getByText('An error occurred')).toBeInTheDocument();
});
```

### 5.3 Essential Test Case Types

#### 5.3.1 Happy Path
```typescript
describe('normal operations', () => {
  it('should process valid input successfully', () => {
    // Normal processing for valid input
  });

  it('should return expected output format', () => {
    // Verify expected output format
  });
});
```

#### 5.3.2 Boundary Testing
```typescript
describe('boundary conditions', () => {
  it('should handle empty string input', () => {
    expect(processText('')).toBe('');
  });

  it('should handle maximum length input', () => {
    const maxInput = 'a'.repeat(1000);
    expect(() => processText(maxInput)).not.toThrow();
  });

  it('should handle null and undefined inputs', () => {
    expect(() => processText(null)).toThrow();
    expect(() => processText(undefined)).toThrow();
  });
});
```

#### 5.3.3 Exception Handling Tests
```typescript
describe('error handling', () => {
  it('should throw specific error for invalid input', () => {
    expect(() => {
      validateEmail('invalid-email');
    }).toThrow('Invalid email format');
  });

  it('should handle network errors gracefully', async () => {
    mockApi.get.mockRejectedValue(new Error('Network error'));
    
    const result = await fetchUserData('123');
    
    expect(result.error).toBe('Failed to fetch user data');
  });
});
```

#### 5.3.4 Edge Case Tests
```typescript
describe('edge cases', () => {
  it('should handle special characters in input', () => {
    const specialInput = '!@#$%^&*()_+{}|:"<>?[]\\;\',./<';
    expect(() => processText(specialInput)).not.toThrow();
  });

  it('should handle concurrent operations', async () => {
    const promises = Array(10).fill(null).map(() => processAsync('test'));
    const results = await Promise.all(promises);
    
    expect(results).toHaveLength(10);
    results.forEach(result => {
      expect(result).toBeDefined();
    });
  });
});
```

## 6. Mock and Stub Usage Standards

### 6.1 Mock Usage Principles

#### 6.1.1 Mocking External Dependencies
```typescript
// ✅ Good Mocking - Specific and clear
jest.mock('../api/userApi', () => ({
  fetchUser: jest.fn(),
  updateUser: jest.fn(),
  deleteUser: jest.fn()
}));

// ❌ Bad Mocking - Too broad
jest.mock('../api', () => ({}));
```

#### 6.1.2 VSCode API Mocking
```typescript
// VSCode API Standard Mocking
jest.mock('vscode', () => ({
  window: {
    createOutputChannel: jest.fn(() => ({
      appendLine: jest.fn(),
      show: jest.fn(),
      dispose: jest.fn()
    })),
    showErrorMessage: jest.fn(),
    showInformationMessage: jest.fn(),
    showWarningMessage: jest.fn()
  },
  workspace: {
    getConfiguration: jest.fn(() => ({
      get: jest.fn(),
      update: jest.fn()
    }))
  },
  Uri: {
    file: jest.fn(),
    parse: jest.fn()
  }
}));
```

### 6.2 Mock Data Management

#### 6.2.1 Test Data Files
```typescript
// __tests__/fixtures/userData.ts
export const mockUserData = {
  valid: {
    id: '123',
    name: 'Test User',
    email: 'test@example.com'
  },
  invalid: {
    id: '',
    name: '',
    email: 'invalid-email'
  }
};

// Usage in tests
import { mockUserData } from './fixtures/userData';

it('should validate user data', () => {
  expect(validateUser(mockUserData.valid)).toBe(true);
  expect(validateUser(mockUserData.invalid)).toBe(false);
});
```

#### 6.2.2 Using Factory Functions
```typescript
// __tests__/factories/userFactory.ts
export const createMockUser = (overrides = {}) => ({
  id: '123',
  name: 'Test User',
  email: 'test@example.com',
  createdAt: new Date('2024-01-01'),
  ...overrides
});

// Usage in tests
it('should handle user with no email', () => {
  const user = createMockUser({ email: null });
  expect(processUser(user)).toThrow();
});
```

## 7. Asynchronous Test Standards

### 7.1 Promise-based Tests
```typescript
describe('async operations', () => {
  it('should resolve with correct data', async () => {
    const result = await fetchData('123');
    expect(result.id).toBe('123');
  });

  it('should reject with error message', async () => {
    await expect(fetchData('invalid')).rejects.toThrow('User not found');
  });
});
```

### 7.2 Time-related Tests
```typescript
describe('timer functionality', () => {
  beforeEach(() => {
    jest.useFakeTimers();
    jest.setSystemTime(new Date('2024-01-01'));
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it('should execute callback after delay', () => {
    const callback = jest.fn();
    delayedExecution(callback, 1000);

    expect(callback).not.toHaveBeenCalled();
    
    jest.advanceTimersByTime(1000);
    
    expect(callback).toHaveBeenCalledTimes(1);
  });
});
```

## 8. React Component Test Standards

### 8.1 Rendering Tests
```typescript
describe('CaretWelcome component', () => {
  it('should render all required elements', () => {
    render(<CaretWelcome />);
    
    expect(screen.getByRole('heading', { level: 1 })).toBeInTheDocument();
    expect(screen.getByText('Welcome to Caret')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Get Started' })).toBeInTheDocument();
  });
});
```

### 8.2 User Interaction Tests
```typescript
describe('user interactions', () => {
  it('should handle button click', async () => {
    const mockOnClick = vi.fn();
    render(<CaretWelcome onStartClick={mockOnClick} />);
    
    const startButton = screen.getByRole('button', { name: 'Get Started' });
    
    await user.click(startButton);
    
    expect(mockOnClick).toHaveBeenCalledTimes(1);
  });

  it('should handle keyboard navigation', async () => {
    render(<CaretWelcome />);
    
    await user.tab();
    
    expect(screen.getByRole('button', { name: 'Get Started' })).toHaveFocus();
  });
});
```

### 8.3 State Change Tests
```typescript
describe('state management', () => {
  it('should update display when props change', () => {
    const { rerender } = render(<UserProfile user={mockUser1} />);
    
    expect(screen.getByText(mockUser1.name)).toBeInTheDocument();
    
    rerender(<UserProfile user={mockUser2} />);
    
    expect(screen.getByText(mockUser2.name)).toBeInTheDocument();
    expect(screen.queryByText(mockUser1.name)).not.toBeInTheDocument();
  });
});
```

## 9. Coverage Measurement and Analysis

### 9.1 Interpreting Coverage Reports
```bash
# Run coverage
npm run test:coverage

# Example result
Statements   : 100% ( 150/150 )
Branches     : 100% ( 45/45 )
Functions    : 100% ( 30/30 )
Lines        : 100% ( 140/140 )
```

### 9.2 Finding Missing Coverage
```typescript
// Items to check when coverage is not 100%

// 1. All if/else branches
if (condition) {
  // Has this part been tested?
} else {
  // Has this part also been tested?
}

// 2. All switch cases
switch (type) {
  case 'A': // Tested
    break;
  case 'B': // Missing test?
    break;
  default: // Tested
}

// 3. All exception handling
try {
  riskyOperation();
} catch (error) {
  // Has this catch block been tested?
}
```

## 10. Test Performance and Optimization

### 10.1 Optimizing Test Speed
```typescript
// ✅ Good Example - Fast tests
describe('utility functions', () => {
  it('should format string quickly', () => {
    const result = formatString('test');
    expect(result).toBe('TEST');
  });
});

// ❌ Bad Example - Slow tests
describe('heavy operations', () => {
  it('should process large dataset', () => {
    const largeData = Array(1000000).fill(0); // Too large data
    const result = processData(largeData);
    expect(result).toBeDefined();
  });
});
```

### 10.2 Test Isolation
```typescript
describe('isolated tests', () => {
  beforeEach(() => {
    // Start with a clean state for each test
    localStorage.clear();
    jest.clearAllMocks();
  });

  it('should not affect other tests', () => {
    localStorage.setItem('test', 'value');
    expect(localStorage.getItem('test')).toBe('value');
  });
});
```

## 11. Continuous Integration (CI) Testing

### 11.1 CI Environment Setup
```yaml
# .github/workflows/test.yml
name: Test Coverage

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm run test:coverage
      
      - name: Check Caret coverage
        run: node caret-scripts/caret-coverage-check.js
      
      - name: Fail if coverage below 100%
        run: |
          if [ "$CARET_COVERAGE" != "100" ]; then
            echo "Caret coverage is below 100%: $CARET_COVERAGE%"
            exit 1
          fi
```

### 11.2 Pre-commit Hook
```bash
#!/bin/sh
# .husky/pre-commit

echo "Running tests before commit..."
npm run test:quick

if [ $? -ne 0 ]; then
  echo "Tests failed. Commit aborted."
  exit 1
fi

echo "Running coverage check..."
npm run test:coverage:check

if [ $? -ne 0 ]; then
  echo "Coverage below 100%. Commit aborted."
  exit 1
fi
```

## 12. Troubleshooting Guide

### 12.1 Common Test Errors

#### 12.1.1 VSCode API Related Errors
```typescript
// Error: Cannot find module 'vscode'
// Solution: Add appropriate mocking
jest.mock('vscode', () => ({
  // Mock only necessary APIs
}));
```

#### 12.1.2 Asynchronous Test Errors
```typescript
// Error: Test timeout
// Solution: Correct use of async/await
it('should handle async operation', async () => {
  await expect(asyncFunction()).resolves.toBeDefined();
});
```

#### 12.1.3 React Test Errors
```typescript
// Error: Unable to find an element
// Solution: Use correct queries
// ❌ Bad Example
screen.getByText('Incorrect text');

// ✅ Good Example
screen.getByRole('button', { name: /Get Started/ });
```

### 12.2 Debugging Tips
```typescript
// Useful tools for debugging tests

// 1. screen.debug() - Output current DOM state
it('should render correctly', () => {
  render(<Component />);
  screen.debug(); // Check DOM structure
});

// 2. console.log to check values
it('should process data', () => {
  const result = processData(input);
  console.log('Result:', result); // Check result value
  expect(result).toBeDefined();
});

// 3. Test isolation check
describe.only('focused test', () => {
  // Only this describe block will run
});

it.only('focused test', () => {
  // Only this test will run
});
```

## 13. Checklist

### 13.1 Test Writing Completion Checklist
- [ ] Tests written for all public methods
- [ ] Tests written for all private methods (if necessary)
- [ ] All if/else branches tested
- [ ] All exception handling tested
- [ ] Boundary value tests (empty string, null, undefined, etc.)
- [ ] Asynchronous operation tests
- [ ] Mock and Stub used appropriately
- [ ] Test names are clear and specific
- [ ] AAA pattern adhered to
- [ ] Test independence ensured

### 13.2 Coverage Achievement Checklist
- [ ] Statement Coverage: 100%
- [ ] Branch Coverage: 100%
- [ ] Function Coverage: 100%
- [ ] Line Coverage: 100%
- [ ] No missing parts in coverage report
- [ ] `caret-scripts/caret-coverage-check.js` passed

### 13.3 Code Quality Checklist
- [ ] Test execution time is reasonable (total < 30 seconds)
- [ ] All tests can run independently
- [ ] Mock usage is appropriate and not excessive
- [ ] Test code is easy to read and understand
- [ ] Duplicate code minimized
- [ ] Test data is clear and meaningful

## 14. References

### 14.1 Related Documents
- [Caret Testing Guide](./testing-guide.mdx)
- [Documentation Guide](./documentation-guide.mdx)
- [AI Work Methodology Guide](../guides/ai-work-method-guide.mdx)

### 14.2 Tools and Libraries
- [Jest Official Documentation](https://jestjs.io/)
- [Vitest Official Documentation](https://vitest.dev/)
- [React Testing Library](https://testing-library.com/)
- [Testing Best Practices](https://github.com/goldbergyoni/javascript-testing-best-practices)

---

**Last Updated**: June 17, 2025 - Initial draft of test writing standards
**Authored by**: Alpha (AI Assistant)
**Reviewed by**: Luke (Developer)
